```{r PBMCsetup, echo=FALSE}
opts_chunk$set(tidy=TRUE, cache=FALSE,  highlight=TRUE, figalign="center", echo=TRUE, warning=FALSE, error=FALSE, message=FALSE, tidy.opts=list(keep.blank.line=FALSE, width.cutoff=120))
options(width=200)
```

# NMF ANALYSES OF PROTEOMIC DATA

---

## Summary  

Analysis of proteomic data for [Leo Wang](mailto:Leo.Wang@childrens.harvard.edu) in the Wager's group at the Joslin.

Nonnegative matrix factorization [(NMF)][1] analysis was conducted on the samples to explore sample similarity and to identify proteins/genes that might be characteristic for individual isolated cell types. NMF tries to identify 'factors' (or metagenes, a weighted list of genes) that best describe individual samples. This is useful to not only identify how similar the samples are, but also in which way they are similar.

Contact [John Hutchinson](mailto:jhutchin@hsph.harvard.edu) for additional details.

The most recent update of this html document occurred: `r date()`

The sections below provide code to reproduce the included results and plots.

---

## Setup

### Libraries 

```{r libraries}
library(NMF)
library(genefilter)
library(ggdendro)
library(ggplot2)
library(GOstats)
library(biomaRt)
library(AnnotationForge)
library(mouse.db0)
library(plyr)
library(googleVis)

ensembl = useMart("ensembl",dataset="mmusculus_gene_ensembl")
attributes <- listAttributes(ensembl)
filters <- listFilters(ensembl)
```

### Functions

```{r functions}
source("http://dl.dropboxusercontent.com/u/4253254/Resources/functions.r")

plot_dendro <- function(x, title="", metadata.colname.identifier="columnid", labels.colname="group_short") {
  meta.x <- pData(x)
  myDist <- dist(t(exprs(x)))
  myTree <-hclust(myDist)
  dhc <- as.dendrogram(myTree)
  ddata <- dendro_data(dhc, type="rectangle")
  ddata$labels <- merge(ddata$labels, meta.x, by.x="label", by.y=metadata.colname.identifier)
  ggplot(segment(ddata)) +
    geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) +
    theme_dendro() +
    geom_text(data=label(ddata), aes(x=x, y=y, label=group_short, color=group_short, hjust=-0.1), size=6) +
    coord_flip() + scale_y_reverse(expand=c(0.2, 50)) +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank()) +
    ggtitle(title)
  }
```

### Variables

```{r variables}
if (file.exists("/n/hsphS10/hsphfs1/chb/projects/aw_NMF_proteomics/")) {
  baseDir <- "/n/hsphS10/hsphfs1/chb/projects/aw_NMF_proteomics/"
  }  else if (file.exists("/Volumes/home08/jhutchin/consults/aw_NMF_proteomics/")) {
    baseDir <- "/Volumes/home08/jhutchin/consults/aw_NMF_proteomics"
    } else {
      baseDir <- "/Volumes/ody/consults/aw_NMF_proteomics"
      }
dataDir <- file.path(baseDir, "data")
resultsDir <- file.path(baseDir, "results")
metaDir <- file.path(baseDir, "meta")
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#000000")

TRAIN=50
RUN=1000
mad.cutoff=0.5
```

---

## Data preparation and exploration

### Load in Data

Both the summed counts and the "normalized" counts were initially analysed in tandem to assess which method led to better results. All counts  log transformed to stabilize variance.

```{r dataload}
data <- read.delim(file.path(dataDir, "data.txt"))
metadata <- read.delim(file.path(metaDir, "metadata.txt")) 

# some very hacky text manipulations occur here to label the results, not sure how to handle rows with the same protein annotations, ended up just pasting the rownumber onto the first gene in the GeneName column
data$GeneName <- lapply(data$GeneName, function(x) gsub(", ", "/", x))
row.names(data) <- paste(row.names(data), annot$GeneName, sep="_")

# grab the annotation columns
annot <- data[,which(metadata$datatype=="descriptor")]

# grab the columns with summed data and log transform, stuff into an ExpressionSet object
data.sum <- data[,which(metadata$datatype=="sum")]
data.sum <- log2(data.sum)
metadata.sum <- subset(metadata, datatype=="sum")
metadata.sum <- col2rownames(metadata.sum, "columnid", FALSE)
eset.sum <- ExpressionSet(assayData=as.matrix(data.sum), phenoData=new("AnnotatedDataFrame", data = metadata.sum), featureData=new("AnnotatedDataFrame", data=annot))

# grab the columns with "normed" data and log transform, stuff into an ExpressionSet object
data.norm <- data[,which(metadata$datatype=="norm")]
data.norm <- log2(data.norm)
metadata.norm <- subset(metadata, datatype=="norm")
metadata.norm <- col2rownames(metadata.norm, "columnid", FALSE)
eset.norm <- ExpressionSet(assayData=as.matrix(data.norm), phenoData=new("AnnotatedDataFrame", data = metadata.norm), featureData=new("AnnotatedDataFrame", data=annot))

rm(data.sum, metadata.sum, data.norm, metadata.norm)
```

### Initial Clustering

Initial hierarchical clustering based on the euclidian distance of individual samples.

```{r clustering, fig.height=8, fig.width=8, fig.show='hold'}
plot_dendro(eset.sum,  title="Summed Data")
plot_dendro(eset.norm, title="Normalized Data")
```

The dendrograms look promising, particularly for the approach without any "normalization", BMM and LSC cell types cluster separately, with the RBM and PM cell types appearing to comprise a subgroup that can be further subdivided into the two separate cell types.

### Principle Component Analyses

```{r PCA, fig.height=8, fig.width=8, fig.show='hold'}
PCAplot.sd(eset.sum,   title="Proportion of Variance Explained by Components  - Summed Data")
PCAplot(eset.sum,  categories="group_short", title="PCA - Summed Data", colorpalette=cbPalette, numcomponents=4)
PCAplot.sd(eset.norm,   title="Proportion of Variance Explained by Components - Normalized Data")
PCAplot(eset.norm,  categories="group_short", title="PCA - Normalized Data", colorpalette=cbPalette, numcomponents=4)
```

The first four components explain ~75% of the sample differences for both approaches to the data, and when compared pairwise, the different combinations of these components can separate out the various combinations of the cell types.

### Remove proteins with low variance between samples

To speed up the computationally intensive NMF clustering, the `r nrow(exprs(eset.sum))`  proteins were filtered to retain only those proteins exhibiting a median absolute deviation from the median (mad) of more than `r mad.cutoff` across all samples.

Note that this is not a test for differential protein levels. Instead, filtering out proteins exhibiting very little variance across all samples removes those that are unlikely to distinguish between cell types.

```{r lowvarremove, fig.height=8, fig.width=8, fig.show='hold'}
rowMads.sum <- apply(exprs(eset.sum), 1, mad)
ggplot(as.data.frame(rowMads.sum), aes(x=rowMads.sum))+geom_density()+xlab("Mean Average Deviation")+ggtitle("Protein Signal Variation in Summed Data")+geom_vline(x=mad.cutoff, col="red", lwd=0.2)
rowMads.norm <- apply(exprs(eset.norm), 1, mad)
ggplot(as.data.frame(rowMads.norm), aes(x=rowMads.norm))+geom_density()+xlab("Mean Average Deviation")+ggtitle("Protein Signal Variation in Normed Data")+geom_vline(x=mad.cutoff, col="red", lwd=0.2)

eset.sum.sub <- eset.sum[which(rowMads.sum>mad.cutoff),]
eset.norm.sub <- eset.norm[which(rowMads.norm>mad.cutoff),]
```

This variance filter reduced the number of probesets to a final set of `r nrow(exprs(eset.sum.sub))`.

To assess the effects of the filtering, I ran the clustering again.

```{r lowvarclusteringplots, fig.show='hold'}
## dendrograms
plot_dendro(eset.sum.sub,  title="Summed Data")
plot_dendro(eset.norm.sub, title="Normalized Data")
## PCA plots
PCAplot.sd(eset.sum.sub,   title="Proportion of Variance Explained by Components  - Summed Data")
PCAplot(eset.sum.sub,  categories="group_short", title="PCA - Summed Data", colorpalette=cbPalette, numcomponents=4)
PCAplot.sd(eset.norm.sub,   title="Proportion of Variance Explained by Components - Normalized Data")
PCAplot(eset.norm.sub, categories="group_short", title="PCA - Normalized Data", colorpalette=cbPalette, numcomponents=4)
```

Hierarchical clustering of cell types based on the expressed probes with a mad variance above `r mad.cutoff` matches the initial clustering.  

As it appears that the samples cluster better by type after simple summing of counts, going forward I worked with the summed counts only.

---

## NMF Preparation

### Estimating the factorization rank
From ["An introduction to NMF package"][2]

>A critical parameter in NMF is the factorization rank r. It determines the number of metagenes used
to approximate the target matrix. Given a NMF method and the target matrix, a common way of
deciding on r is to try different values, compute some quality measure of the results, and choose
the best value according to this quality criteria.

#### Using metrics:

From ["An introduction to NMF package"][2]

>(Brunet et al. 2004) proposed to take the first value of r for which the cophenetic coefficient starts
decreasing, (Hutchins et al. 2008) suggested to choose the first value where the RSS curve presents
an inflection point, and (Frigyesi et al. 2008) considered the smallest value at which the decrease
in the RSS is lower than the decrease of the RSS obtained from random data.

```{r estimatefactoriziationrank, results='hide', cache=TRUE, fig.height=8, fig.width=16}
groups.sum.sub <-  as.factor(eset.sum.sub$group_short)
estim.sum.sub <- nmf(eset.sum.sub, 2:7, nrun = TRAIN, seed = 123456)
plot(estim.sum.sub)
```

Even for random data,  increasing factorization ranks lead to more variables to fit the data, possibly leading to overfitting the data. Too assess this, we can run the same metrics after randomly permuting the data, and comparing the performance of the original and randomized datasets. 

These results suggest there are at least 3-5 metagenes as :
1) the cophenetic curve starts decreasing at the 5th factorization rank
2) the largest inflection point of the rss curve occurs at the 3rd factorization rank

```{r overfitcheck, results='hide',cache=TRUE, fig.height=8, fig.width=16 }
# shuffle original data to look for overfitting
eset.sum.sub.rand <- randomize(eset.sum.sub)
# estimate quality measures from the shuffled data (use default NMF algorithm)
estim.sum.sub.rand <- nmf(eset.sum.sub.rand, 2:7, nrun = TRAIN, seed = 123456)
# plot measures on same graph
plot(estim.sum.sub, estim.sum.sub.rand)
```

In the plots below, the blue (and green) lines represent the actual data while the red (and pink) lines represent the same data after random shuffling by permuting the rows of each column, using a different permutation each time. These results show that overfitting is not an issue.

#### Qualitative assessment

We can also examine heatmaps of the consensus matrix for each value of the factorization rank to see if the clusters (or consensus blocks) obtained correspond to the known cell types.

```{r estimatefactoriziationrank.qualitative, results='hide', fig.height=12, fig.width=12}
consensusmap(estim.sum.sub$fit,  annCol=as.character(unlist(eset.sum.sub$group_short )),  labCol=groups.sum.sub, labRow=groups.sum.sub)
```

It appears that there are 3-5 factors that can be used to divide the samples. At rank 3 , we can separately classify the LSC  samples (consensus block 2), but not the BMM, PM and RBM samples (consensus block 3). Increasing the stringency, at rank 4 we can  classify the  RBM samples (consensus block 4); the PM samples can be classified to some extent at rank 5 (consensus block 5). The BMM samples do not cluster to any extent at any level. 

This suggests a model where LSC samples are largely unique while PM and RBM samples are subgroups of a larger group. The BMM samples, while largely different from the other samples, also appear to be different from each other.

Going forward, I only looked at factorization ranks of 3 and 5.

### Choosing an algorithm

To this point, I have been using the default (*brunet*) algorithm for the gross tuning of NMF; we can further fine tune NMF by choosing an alternate algorithm.
 
To do so, I ran NMF on the data using four of the most popular algorithms (with error tracking enabled), and compared the error plots. In these error plots, each track is normalized so that its first value equals one, and stops at the iteration where the method's convergence criterion was fulfilled; algorithms that converge at lower objective values are optimal.

```{r comparealgs, cache=TRUE, fig.height=8, fig.width=8}
res.multi.method.3 <- nmf(eset.sum.sub, 3, list("brunet", "KL", "lee","nsNMF"), nrun=TRAIN, seed = 123456, .options = "t")
res.multi.method.5 <- nmf(eset.sum.sub, 5, list("brunet", "KL", "lee",  "nsNMF"), nrun=TRAIN, seed = 123456, .options = "t")

plot(res.multi.method.3)
plot(res.multi.method.5)
```

Here, the *nsMMF* algorirthm works best for 3 metagenes and is roughly equal to the *lee* algortihm for 5 metagenes. The nsNMF approach has the slight benefit of creating 'sparse' metagenes which are easier to interpret functionally, so I proceeded with this algorithm.

---

## Complete NMF Algorithm

The NMF analyses so far have used a low number of iterations (<50), here I ran NMF with `r RUN` iterations to get accurate a result as possible.

```{r fullNMF, cache=TRUE}
res.final.3 <- nmf(eset.sum.sub, 3, "nsNMF", nrun=RUN, .options = "t")
res.final.5 <- nmf(eset.sum.sub, 5, "nsNMF", nrun=RUN, .options = "t")
```

---

## NMF Metagene Feature Extraction

We can extract the genes that comprise the metagenes that define our different classes.

### Metagene features when using 3 Rank Factorization

```{r rank3plots, fig.show='asis'}
consensusmap(res.final.3,  annCol=as.character(unlist(eset.sum.sub$group_short )),  labCol=groups.sum.sub, labRow=groups.sum.sub)
basismap(res.final.3, subsetRow=TRUE) # shows metagnes in relation to samples
coefmap(res.final.3, labCol=groups.sum.sub) # shows the individual genes in relation to metagenes and samples
 
bestfit3 <- fit(res.final.3) #extract the best fit NMf model
fs3 <- featureScore(bestfit3) # get all the feature scores which measure specificity to which a gene contributes to a metagene
f3 <- extractFeatures(bestfit3) # extract the features with the most specifciity for each of the metagenes
## get unique annotations for genes (NMF returns number referenced IDs) in metagenes
unique.metagenesymbols <- lapply(f3, function(x) {
  genenames <- unique(unlist(fData(eset.sum.sub)[x,"GeneName"]))
  return(genenames)
  })
## get number of unique genes in each metagene
numgenes <- unlist(lapply(unique.metagenesymbols, length))
```

We can classify LSC cells by  clustering on three metagenes (of  `r numgenes[1]`,`r numgenes[2]` and `r numgenes[3]` genes respectively) with different weights for each sample. Looking at the coefficient plot, metagene 3 appears to best reflect LSC cells, metagene 2 a single BMM sample, and metagene 1 a mixture of PM, RBM and BMM samples. 

We can extract the genes that make the strongest contribution to the different metagenes. The featurescore of each gene reflects the degree of specificity to which it contributes to a metagene.

```{r rank3.metagenes}
# dataframe to present the metagene features that includes both the metagene annotations and the featurescores
metagene.1 <- cbind(fData(eset.sum.sub)[f3[[1]],], fs3[f3[[1]]]) 
names(metagene.1)[4] <- "featurescore"
metagene.2 <- cbind(fData(eset.sum.sub)[f3[[2]],], fs3[f3[[2]]]) 
names(metagene.2)[4] <- "featurescore"
metagene.3 <- cbind(fData(eset.sum.sub)[f3[[3]],], fs3[f3[[3]]]) 
names(metagene.3)[4] <- "featurescore"

write.table(as.matrix(metagene.1), file=file.path(resultsDir, paste("Rank3.metagenes", 1, "xls", sep=".")), sep="\t", quote=F)
write.table(as.matrix(metagene.2), file=file.path(resultsDir, paste("Rank3.metagenes", 2, "xls", sep=".")), sep="\t", quote=F)
write.table(as.matrix(metagene.3), file=file.path(resultsDir, paste("Rank3.metagenes", 3, "xls", sep=".")), sep="\t", quote=F)
```

#### Rank 3 Metagene #3 features (LSC specific metagene)

```{r LSC.metagene.print, results='asis', echo=FALSE}
metagene.3.gvis <- gvisTable(as.data.frame(apply(metagene.3, 2, as.character)), options = list(width = 960, height=1600))  
print(metagene.3.gvis, "chart")
```

[link to Excel file of Rank 3 metagene number 1 features](./results/Rank3.metagenes.1.xls) 

[link to Excel file of Rank 3 metagene number 2 features](./results/Rank3.metagenes.2.xls)

[link to Excel file of Rank 3 metagene number 3 features](./results/Rank3.metagenes.3.xls)

##### Gene Ontology Analyses of LSC metagene features
Looking for  functional enrichment (Biological Process ontologies) in the list of genes contained within the LSC metagene with the [GOstats][3]. (for a good intro to Gene Onotology see ([GO][4])) 

```{r GOlsc}
# extract only first gene listed, when multiple gene names found in a single annotation row 
genes.of.interest <- unique(unlist(lapply(metagenelsc$GeneName, function(x) unlist(strsplit(x, split="/"))[1])))
background.genes <- unique(unlist(lapply(fData(eset.sum.sub)[,"GeneName"], function(x) unlist(strsplit(x, split="/"))[1]))) # all the genes tested in the NMF analysis

GO.results <- GOstats.genesymbols(genesymbols=genes.of.interest, background.genesymbols=background.genes, biomaRt.filter="mgi_symbol", pvalue.cutoff=0.05, annotation="mouse4302" ) # used the mouse4302 db here, best practices
# but you need some sort of annotation database to link to the gene ontologies, and I at least know the microarray annotations work with GOstats
```


```{r GOlscprint, results='asis'}
GOresults.lsc.gvis <- gvisTable(as.data.frame(apply(GO.results, 2, as.character)), options = list(width = 960, height=1600))  
print(GOresults.lsc.gvis, "chart")
```

*these GO results are likely pretty unreliable as the method 1) was originally designed to work with microarrays and 2) has no easy method to work with multi-hits in the data ie. for data points annotated with mulitple genes, I simply picked the first  gene from the annotations, an oversimplification as the mass spec data points could likely originate from multiple different genes with identical protein domains*

---

### Metagene features when using 5 Rank Factorization

```{r rank5plots, fig.show='hold'}
consensusmap(res.final.5,  annCol=as.character(unlist(eset.sum.sub$group_short )),  labCol=groups.sum.sub, labRow=groups.sum.sub)
basismap(res.final.5, subsetRow=TRUE) # shows metagnes in relation to samples
coefmap(res.final.5, labCol=groups.sum.sub) # shows the individual genes in relation to metagenes and samples
 
bestfit5 <- fit(res.final.5) #extract the best fit NMf model
fs5 <- featureScore(bestfit5) # get all the feature scores which measure specificity to which a gene contributes to a metagene
f5 <- extractFeatures(bestfit5) # extract the features with the most specifciity for each of the metagenes
## get annotations for genes (numbered) in metagenes
unique.metagenesymbols <- lapply(f5, function(x) {
  genenames <- unique(unlist(fData(eset.sum.sub)[x,"GeneName"]))
  return(genenames)
  })
## get number of unique genes in each metagene
numgenes <- unlist(lapply(unique.metagenesymbols, length))
```

To properly classify the RBM and PM cells, we have to use at least 5 metagenes. 
Based on five metagenes (of  `r numgenes[1]`,`r numgenes[2]`, `r numgenes[3]` , `r numgenes[4]` and `r numgenes[5]` genes respectively) Metagene 3 & 5 reflect RBM  cells, while a combination of metagenes 4,  5 and NOT 3 best reflect PM cells. 

Once again, we can extract the genes that make the strongest contribution to a metagene (here we are mainly interested in metagenes 3, 4 and 5).

```{r rank5.metagenes}
# dataframe to present the metagene features that includes annotations and the featurescores
metagene.1 <- cbind(fData(eset.sum.sub)[f5[[1]],], fs5[f5[[1]]]) 
names(metagene.1)[4] <- "featurescore"
metagene.2 <- cbind(fData(eset.sum.sub)[f5[[2]],], fs5[f5[[2]]]) 
names(metagene.2)[4] <- "featurescore"
metagene.3 <- cbind(fData(eset.sum.sub)[f5[[3]],], fs5[f5[[3]]]) 
names(metagene.3)[4] <- "featurescore"
metagene.4 <- cbind(fData(eset.sum.sub)[f5[[4]],], fs5[f5[[4]]]) 
names(metagene.4)[4] <- "featurescore"
metagene.5 <- cbind(fData(eset.sum.sub)[f5[[5]],], fs5[f5[[5]]]) 
names(metagene.5)[4] <- "featurescore"

write.table(as.matrix(metagene.1), file=file.path(resultsDir, paste("Rank3.metagenes", 1, "xls", sep=".")), sep="\t", quote=F)
write.table(as.matrix(metagene.2), file=file.path(resultsDir, paste("Rank3.metagenes", 2, "xls", sep=".")), sep="\t", quote=F)
write.table(as.matrix(metagene.3), file=file.path(resultsDir, paste("Rank3.metagenes", 3, "xls", sep=".")), sep="\t", quote=F)
write.table(as.matrix(metagene.4), file=file.path(resultsDir, paste("Rank3.metagenes", 4, "xls", sep=".")), sep="\t", quote=F)
write.table(as.matrix(metagene.5), file=file.path(resultsDir, paste("Rank3.metagenes", 5, "xls", sep=".")), sep="\t", quote=F)
```

[link to Excel file of Rank 5 metagene number 1 features](./results/Rank5.metagenes.1.xls)

[link to Excel file of Rank 5 metagene number 2 features](./results/Rank5.metagenes.2.xls)

[link to Excel file of Rank 5 metagene number 3 features](./results/Rank5.metagenes.3.xls)

[link to Excel file of Rank 5 metagene number 4 features](./results/Rank5.metagenes.4.xls)

[link to Excel file of Rank 5 metagene number 5 features](./results/Rank5.metagenes.5.xls)

#### RBM Metagenes features (Rank 5 metagenes #3 and #5)

```{r Rank5.metagenes.3.5.print, echo=FALSE, results='asis'}
metagene.3.5 <- rbind(metagene.3, metagene.5)
metagene.3.5.gvis <- gvisTable(as.data.frame(apply(metagene.3.5, 2, as.character)), options = list(width = 960, height=1600))  
print(metagene.3.5.gvis, "chart")
```

##### Gene Ontology Analyses of RBM metagenes' features

Looking for functional enrichment (Biological Process ontologies) in the list of genes contained within this metagene combination.

```{r GOrmb, results='asis'}
# split up genes in list, when multiple genes
genes.of.interest <- unique(unlist(lapply(metagene.3.5$GeneName, function(x) unlist(strsplit(x, split="/")))))
background.genes <- unique(unlist(lapply(fData(eset.sum.sub)[,"GeneName"], function(x) unlist(strsplit(x, split="/")))))
GO.results <- GOstats.genesymbols(genesymbols=genes.of.interest, background.genesymbols=background.genes, biomaRt.filter="mgi_symbol", pvalue.cutoff=0.05, annotation="mouse4302" )

GOresults.rmb.gvis <- gvisTable(as.data.frame(apply(GO.results, 2, as.character)))  
print(GOresults.rmb.gvis, "chart")
```

*same caveats as above apply* 

#### PM Metagenes features (Rank 5 metagenes #4 and #5)

```{r Rank5.metagenes.4.5.print, results='asis', echo=FALSE}
metagene.4.5 <- rbind(metagene.4, metagene.5)
metagene.4.5.gvis <- gvisTable(as.data.frame(apply(metagene.4.5, 2, as.character)), options = list(width = 960, height=1600))  
print(metagene.4.5.gvis, "chart")
```

#### Gene Ontology Analyses of metagene features
Looking for  functional enrichment (Biological Process ontologies) in the list of genes contained within these metagene combinations.

```{r GOpm, results='asis'}
# split up genes in list, when multiple genes
genes.of.interest <- unique(unlist(lapply(metagene.4.5$GeneName, function(x) unlist(strsplit(x, split="/")))))
background.genes <- unique(unlist(lapply(fData(eset.sum.sub)[,"GeneName"], function(x) unlist(strsplit(x, split="/")))))
GO.results <- GOstats.genesymbols(genesymbols=genes.of.interest, background.genesymbols=background.genes, biomaRt.filter="mgi_symbol", pvalue.cutoff=0.05, annotation="mouse4302" )

GOresults.pm.gvis <- gvisTable(as.data.frame(apply(GO.results, 2, as.character)), options = list(width = 960, height=1600))  
print(GOresults.pm.gvis, "chart")
```

*same caveats as above apply* 

```{r savesession, echo=FALSE}
sessionInfo()
save.image(file.path(resultsDir, "RDATA"))
```

[1]: http://www.biomedcentral.com/1471-2105/11/367 (NMF)
[2]: http://nmf.r-forge.r-project.org/vignettes/NMF-vignette.pdf (NMF vignette)
[3]: http://www.bioconductor.org/packages/release/bioc/html/GOstats.html (GOstats)
[4]: http://www.geneontology.org/GO.doc.shtml (GO)