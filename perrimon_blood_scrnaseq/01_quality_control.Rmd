---
title: "Perrimon Lab blood scRNA-Seq quality control"
date: "`r BiocStyle::doc_date()`"
author: "Michael J. Steinbaugh"
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)

library(biomaRt)
library(cowplot)
library(Matrix)
library(mltools)
library(pheatmap)
library(scales)
library(Seurat)
library(tools)

library(basejump)
library(tidyverse)
```

[BPF]: https://genome.med.harvard.edu
[Ensembl]: http://useast.ensembl.org/Drosophila_melanogaster/Info/Index
[FlyBase]: http://flybase.org
[inDrop]: http://1cell-bio.com
[Orchestra]: https://wiki.med.harvard.edu/Orchestra
[scRNA-Seq]: http://bcbio-nextgen.readthedocs.io/en/latest/contents/configuration.html#single-cell-rna-sequencing

[`bcbio-nextgen`]: https://bcbio-nextgen.readthedocs.io
[`bcl2fastq`]: https://support.illumina.com/downloads/bcl2fastq-conversion-software-v217.html
[`biomaRt`]: https://bioconductor.org/packages/release/bioc/html/biomaRt.html
[`rapmap`]: https://github.com/COMBINE-lab/RapMap
[`umis`]: https://github.com/vals/umis

# Overview

2000 cells were sequenced using the [inDrop][] v3 platform. 

- `M`: Data for another group
- `sorted`: Fluorescence-activated cell sorting (FACS)-sorted GFP+ immune cells.
- `unsorted`: All cells. Note that this group is also GFP+.

Only `sorted` and `unsorted` samples are relevant to the analysis. We'll filter `M` from further downstream quality control checks.


## [inDrop][] pipeline history

- v1: Original design
    - R1: metadata read
    - R2: biological read
- v2: Inversion of v1
- v3: Summer 2016 redesign, requiring manual demultiplexing
    - R1: biological read
    - R2: first half of the gel barcode
    - R3: library index
    - R4: second half of the gel barcode, the UMI, and a fraction of the polyA tail



# Analysis workflow

## Demultiplexing

We demultiplexed the raw Illumina BCL files provided by the [Harvard Biopolymers Facility][bpf] into FASTQ format using [`bcl2fastq`][]. This step generates files with the following suffixes:

- `_R1`: 61 bp read 1, transcript
- `_R2`: 8 bp index read 1 (i7), single cell barcode
- `_R3`: 8 bp index read 2 (i5), library index
- `_R4`: 14 bp read 2, barcode and unique molecular identifiers (UMIs)

We ran this on [Orchestra][] with the following settings:

```{bash, eval=FALSE, include=TRUE}
module load seq/bcl2fastq/2.17.1.14
bcl2fastq --use-bases-mask y*,y*,y*,y* --mask-short-adapter-reads 0 --minimum-trimmed-read-length 0
```


## Count filtering and alignment

### [FlyBase][] transcriptome annotations

We aligned the counts using the latest transcriptome FASTA from [FlyBase][], [`dmel-all-transcript-r6.14.fasta`](ftp://ftp.flybase.net/genomes/Drosophila_melanogaster/dmel_r6.14_FB2017_01/fasta/dmel-all-transcript-r6.14.fasta.gz) (Feb 2017).

```{r bcbio, include=FALSE}
# HPC mount point over `sshfs` connection
hpc_dir <- "/Users/mike/Orchestra/bcbio/PIs/norbert_perrimon/blood_scrnaseq"
if (!length(dir(hpc_dir))) {
    stop("Project on HPC server not loaded.")
}
print(hpc_dir)
dir(hpc_dir)

# `bcbio-nextgen`
final_dir <- file.path(hpc_dir, "indrop_rnaseq", "final")
print(final_dir)
dir(final_dir)

# Default naming scheme is `indrop_rnaseq/final/YYYY-MM-DD_indrop_rnaseq`
summary_dir <- file.path(final_dir) %>%
    dir(full.names = TRUE) %>%
    .[grepl("/\\d{4}-\\d{2}-\\d{2}_indrop_rnaseq$", .)]
print(summary_dir)
dir(summary_dir)

# Create directories if necessary
if (!file.exists("data")) {
    dir.create("data")
}
if (!file.exists("results")) {
    dir.create("results")
}
```

### Additional [Ensembl][] annotations

We used [`biomaRt`][] to obtain additional metadata from [Ensembl][] for each transcript, namely the `biotype`.

```{r annotations}
mart <- biomaRt::useMart("ENSEMBL_MART_ENSEMBL", "dmelanogaster_gene_ensembl")
mart_attributes <- biomaRt::listAttributes(mart)
annotations <- biomaRt::getBM(mart = mart,
                              attributes = c("ensembl_gene_id",
                                             "ensembl_transcript_id",
                                             "external_gene_name",
                                             "external_transcript_name",
                                             "gene_biotype",
                                             "transcript_biotype",
                                             "chromosome_name"))
# Broad class definitions
# Terms are sorted alphabetically here
coding <- c("protein_coding")
decaying <- c("non_stop_decay",
              "nonsense_mediated_decay")
noncoding <- c("known_ncrna",
               "lincRNA",
               "non_coding")
srna <- c("miRNA",
          "misc_RNA",
          "ribozyme",
          "rRNA",
          "scaRNA",
          "scRNA",
          "snoRNA",
          "snRNA",
          "sRNA")
annotations$broad_class <-
    dplyr::case_when(grepl("mito", annotations$chromosome_name) ~ "mito",
                     grepl("pseudo", annotations$gene_biotype) ~ "pseudo",
                     grepl("TR_", annotations$gene_biotype) ~ "TCR",
                     grepl("IG_", annotations$gene_biotype) ~ "IG",
                     annotations$gene_biotype %in% srna ~ "small",
                     annotations$gene_biotype %in% decaying ~ "decaying",
                     annotations$gene_biotype %in% noncoding ~ "noncoding",
                     annotations$gene_biotype %in% coding ~ "coding",
                     TRUE ~ "other")

coding <- annotations %>%
    subset(broad_class == "coding") %>%
    .$ensembl_transcript_id %>%
    basejump::sortUnique(.)
mito <- annotations %>%
    subset(broad_class == "mito") %>%
    .$ensembl_transcript_id %>%
    basejump::sortUnique(.)

save(annotations, file = "data/annotations.rda")
write.csv(annotations, "results/annotations.csv")
rm(mart, mart_attributes)
```

```{r tx2name}
tx2name <- annotations %>%
    .[, c("ensembl_transcript_id",
          "external_transcript_name")] %>%
    unique
save(tx2name, file = "data/tx2name.rda")
```

```{r matrix}
counts <- file.path(summary_dir, "tagcounts.mtx") %>%
    Matrix::readMM(.)
rownames(counts) <- file.path(summary_dir, "tagcounts.mtx.rownames") %>%
    readr::read_lines(.)
colnames(counts) <- file.path(summary_dir, "tagcounts.mtx.colnames") %>%
    readr::read_lines(.)
save(counts, file = "data/counts.rda")
# Check the `colnames` and `rownames`
#` head(counts@Dimnames[[1]])
#` head(counts@Dimnames[[2]])
```

### Sample barcodes

We require there to be at least 10,000 reads to match a cellular barcode before aligning.

```{r sample_barcodes}
sample_barcodes <- file.path(hpc_dir, "sample_barcodes.log") %>%
    read.table(col.names = c("counts", "reverse_complement"))
indrop <- file.path("data-raw", "indrop.xlsx") %>%
    readxl::read_excel(.) %>%
    dplyr::left_join(sample_barcodes, by = "reverse_complement")
indrop_metadata <- indrop[, c("reverse_complement", "sample")]
save(indrop, indrop_metadata, file = "data/indrop.rda")
rm(sample_barcodes)
printTable(indrop, caption = "InDrop sample barcodes with counts")
```



# Quality control metrics

```{r metrics}
# `rmarkdown::render()` doesn't appear to handle `dgTMatrix` objects properly.
# Fails on `colSums(counts)` unless we convert `counts` to a matrix first.
counts_matrix <- as.matrix(counts)
metrics <- data.frame(identifier = colnames(counts_matrix),
                      total_counts = colSums(counts_matrix),
                      genes_detected = colSums(counts_matrix > 0),
                      coding_counts = colSums(counts_matrix[rownames(counts_matrix) %in% coding, ]),
                      mito_counts = colSums(counts_matrix[rownames(counts_matrix) %in% mito, ])) %>%
    tidyr::separate(identifier,
                    c("sample_barcode", "cellular_barcode"),
                    sep = ":",
                    remove = FALSE) %>%
    dplyr::mutate(log_detected_per_count = log(genes_detected) / log(total_counts),
                  percent_mito = mito_counts / total_counts,
                  sample_barcode = gsub("^.*-([ACGT]+)$", "\\1", sample_barcode)) %>%
    dplyr::left_join(indrop_metadata, by = c("sample_barcode" = "reverse_complement")) %>%
    dplyr::select(sample, dplyr::everything()) %>%
    dplyr::arrange(sample, identifier)
save(metrics, file = "data/metrics.rda")
write.csv(metrics, "results/metrics.csv")
rm(counts_matrix)
```

We have filtered the `M` samples from quality control analysis.

```{r metrics_filter}
metrics <- dplyr::filter(metrics, sample != "M")
```


## Total number of cells

Significantly more cells were analyzed in the FACS sorted group than the expected amount of 2000. We got a relatively low recovery rate of the unsorted cells.

```{r total_cells}
total_cells <- metrics %>%
    dplyr::group_by(sample) %>%
    dplyr::summarise(total_cells = n())
save(total_cells, file = "data/total_cells.rda")

total_cells %>%
    ggplot(aes(sample,
               total_cells,
               fill = sample)) +
    geom_bar(stat = "identity") +
    geom_text(aes(label = total_cells)) +
    ggtitle("total number of cells") +
    theme(legend.position = "none") +
    ylab("cell count (10k read minimum)")
```



## Total RNA read counts

When sequencing more cells, we have overall less counts per cell. The distribution of counts looks reasonable; we are truncating the lower end because we required there to be at least 10,000 reads to match a barcode before aligning. We can see there is a broad spread of counts per cell. Overall the total number of counts per cell seems on the low side, but HSCs are small cells and with smaller cells we tend to capture less RNA to sequence.

The total counts look reasonable, we're capturing about 10,000 counts per cell on average. If we plot the distribution of counts we can see that there seem to be two sets of cells, one with a lower number of total counts and one with a higher number of total counts. We can probably chop the low total count cells off, as those are likely to be failed cells.

```{r total_counts}
metrics %>%
    ggplot(aes(sample,
               total_counts,
               fill = sample)) +
    geom_boxplot() +
    geom_label(data = aggregate(total_counts ~ sample, metrics, median),
              aes(label = round(total_counts))) +
    ggtitle("total RNA read counts") +
    scale_y_log10() +
    theme(legend.position = "none") +
    ylab("counts per cell")

metrics %>%
    ggplot(aes(total_counts,
               fill = sample)) +
    facet_wrap(~sample) +
    geom_histogram() +
    ggtitle("total counts") +
    scale_x_log10() +
    scale_y_log10() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          legend.position = "none") +
    xlab("counts per cell")
```



## Genes detected

Here we mean genes with a non-zero count measurement per cell.

By detected, we mean a gene has > 0 counts. We can see that as we sequence less deeply due to sequencing more cells, we detect less genes per sample. Overall the number of genes detected per cell is low, again that might be due to the HSCs being small cells.

We detect around 800 genes per cell across all of the replicates on average, and around 350 per cell if we take the median. There are a set of cells with low counts and low genes detected in all of the samples.

```{r genes_detected}
metrics %>%
    ggplot(aes(sample,
               genes_detected,
               fill = sample)) +
    geom_boxplot() +
    geom_label(data = aggregate(genes_detected ~ sample, metrics, median),
              aes(label = round(genes_detected))) +
    ggtitle("genes detected") +
    theme(legend.position = "none") +
    ylab("genes per cell")

metrics %>%
    ggplot(aes(genes_detected,
               fill = sample)) +
    facet_wrap(~sample) +
    geom_histogram() +
    ggtitle("genes detected") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          legend.position = "none") +
    xlab("genes per cell")
```



## Total vs. detected

Here we can see a subset of the cells in each sample that have a very low number of genes detected. These can be cells that have failed in sequencing or they could be cell types that express very low amount of mRNA.

We can see two features of these plots. The first is a set of cells with very low counts on the left hand side of these plots. The second is a set of cells with a moderate number of counts but a low number of genes detected. The first set of cells are likely failed cells we can filter out; the second set is likely to be cells that are undergoing a stressor and are churning out mitochondrial transcripts.

```{r total_vs_detected}
metrics %>%
    ggplot(aes(total_counts,
               genes_detected)) +
    facet_wrap(~sample) +
    geom_point() +
    geom_smooth(method = "loess") +
    ggtitle("total counts vs. genes detected") +
    scale_x_log10() +
    scale_y_log10() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    xlab("counts per cell") +
    ylab("genes per cell")
```



## Mitochondrial counts

It looks like there is a significant amount of cell death occuring during the FACS sorting step.

Here we can see that there is a subset of the cells that have a high amount of counts in mitochondrial genes. These are generally indicative of failed cells, and we should exclude them from the analysis.

```{r mitochondrial_counts}
metrics %>%
    ggplot(aes(coding_counts,
               mito_counts,
               color = sample)) +
    facet_wrap(~sample) +
    ggtitle("mitochondrial gene abundance") +
    geom_point() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          legend.position = "none") +
    ylab("counts in coding genes") +
    xlab("counts in mitochondrial genes")
```



## Total vs detected, revisited

If we color the total counts vs genes detected plot, we can see that the cells that have a lower number of genes detected tend to have a higher mitochondrial percentage. We can see from the histogram if we exclude cells with > 20% mitochondrial reads, we’ll remove the shoulder on the percent mitochondrial distributions, so we’ll use that as the cutoff. We can see this doesn't capture all of the cells with this feature though, for example the shoulder on P5_4 cannot be explained by mitochondrial content. If we drop cells with > 20% mitochondrial content we go from `r nrow(metrics)` to `r table(metrics$percent_mito < 0.2)[2]`.

If we color the total counts vs genes detected plot, we can see that the cells that have a lower number of genes detected tend to have a higher mitochondrial percentage. We can see from the histogram if we exclude cells with > 20% mitochondrial reads, we’ll remove the shoulder on the percent mitochondrial distributions, so we’ll use that as the cutoff.

```{r total_vs_detected_revisited}
metrics %>%
    ggplot(aes(total_counts,
               genes_detected,
               color = percent_mito)) +
    facet_wrap(~sample) +
    geom_point() +
    geom_smooth(method = "lm") +
    scale_x_log10() +
    scale_y_log10() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    xlab("counts per cell") +
    ylab("genes per cell")
```

```{r percent_mito}
metrics %>%
    ggplot(aes(percent_mito,
               fill = sample)) +
    facet_wrap(~sample) +
    geom_histogram() +
    scale_y_sqrt() +
    theme(legend.position = "none")
```

```{r mito_filtered}
metrics %>%
    subset(percent_mito < 0.2) %>%
    ggplot(aes(total_counts,
               genes_detected)) +
    ggtitle("cells with > 20% mitochondrial reads filtered") +
    facet_wrap(~sample) +
    geom_point() +
    geom_smooth(method = "lm") +
    scale_x_log10() +
    scale_y_log10() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    xlab("counts") +
    ylab("genes")
```



## Novelty

Another way to QC the data is to look for less novelty, that is cells that have less genes detected per count than other cells. We can see the samples where we sequenced each cell less have a higher overall novelty, that is because we have not started saturated the sequencing for any given gene for these samples. Outlier cells in these samples might be cells that we have a less complex RNA species than other cells. Sometimes we can detect contamination with low complexity cell types like RBCs or white blood cells via this metric.

```{r novelty}
metrics %>%
    ggplot(aes(sample,
               log_detected_per_count,
               fill = sample)) +
    geom_boxplot() +
    ggtitle("novelty") +
    geom_label(data = aggregate(log_detected_per_count ~ sample, metrics, median),
              aes(label = round(log_detected_per_count, digits = 2))) +
    theme(legend.position = "none") +
    ylab("log genes detected per count")

metrics %>%
    ggplot(aes(log_detected_per_count,
               fill = sample)) +
    facet_wrap(~sample) +
    geom_histogram() +
    ggtitle("novelty") +
    scale_y_sqrt() +
    theme(legend.position = "none") +
    xlab("log genes detected per count")
```



# Summary

These samples look okay, but have a lower amount of genes detected and total counts than I was expecting. Sequencing these samples more might be an option. I think we are ready to go forward-- before clustering we'll filter out high mitochondrial content samples and low novelty samples to get rid of a bunch of the junk that was sequenced.



# Suggested filtering

3k cells per sample were captured, so we're expecting there to be around 48k cells
total. If we filter the cells by keeping only cells that:

1. Have a novelty score > 0.8
2. Have a mitochondrial percentage less than 20%
3. Have at least 500 genes detected

That leaves us with 52k cells with a median of 2800 genes per sample. This seems like a set of reasonable cutoffs to start. Below we plot the what these samples look like in terms of genes detected and total counts. You can see we dropped the shoulder on most of the samples. We can also see there is a fat tailed distribution of genes detected in the samples. If we further drop samples with a high number of genes detected (> 5000), that leaves us with around 50k cells. I think including that filter makes good sense.

```{r filtered}
filtered <- metrics %>%
    dplyr::filter(genes_detected > 500 &
                      percent_mito < 0.20 &
                      log_detected_per_count > 0.8)

filtered %>%
    ggplot(aes(total_counts,
               genes_detected)) +
    facet_wrap(~sample) +
    geom_point() +
    geom_smooth(method = "lm") +
    scale_x_log10() +
    scale_y_log10() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))

filtered %>%
    ggplot(aes(genes_detected,
               fill = sample)) +
    facet_wrap(~sample) +
    geom_histogram() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          legend.position = "none")
```

```{r filtered_high_genes}
filtered_high_genes <- subset(filtered, genes_detected < 5000)

filtered_high_genes %>%
    ggplot(aes(total_counts,
               genes_detected)) +
    facet_wrap(~sample) +
    geom_point() +
    geom_smooth(method = "lm") +
    scale_x_log10() +
    scale_y_log10() +
    xlab("counts per cell") +
    ylab("genes per cell")

filtered_high_genes %>%
    ggplot(aes(genes_detected,
               fill = sample)) +
    facet_wrap(~sample) +
    geom_histogram() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          legend.position = "none") +
    xlab("genes per cell")
```



# Methods

- [`bcl2fastq`][]
- [`bcbio-nextgen`][] scRNA-Seq pipeline
- [`rapmap`][]

```{r}
sessionInfo()
```



# References
