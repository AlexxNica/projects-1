```{r setup, echo=FALSE}
opts_chunk$set(tidy=TRUE, echo=FALSE, highlight=TRUE, figalign="center",
               warning=FALSE, error=FALSE, messages=FALSE, fig.cap="")
```

```{r libraries}
library(edgeR)
library(stringr)
library(HTSFilter)
library(googleVis)
```

# Overview
This dataset has three replicates for each of the following experimental
conditions for 12 total samples.

1) WT MEF cells
2) WT MEF cells treated with cholesterol
3) NRF1 KO cells
4) NRF1 KO cells treated with cholesterol.

```{r utility-functions, echo=FALSE}
ensembl_gene = 'mmusculus_gene_ensembl'
gene_symbol = 'mgi_symbol'
filter_type = 'ensembl_gene_id'
annotate_df_for_filtering = function(d) {
	require(biomaRt)
	ensembl = useMart('ensembl', dataset = ensembl_gene)
	a = getBM(attributes=c(filter_type, gene_symbol, "description", "gene_biotype",
                    "chromosome_name"),
		filters=c(filter_type), values=d[, 'id'],
		mart=ensembl)
	m = merge(d, a, by.x="id", by.y=filter_type)
	#names(m)[which(names(m)=="Row.names")]= "id"
	return(m)
}
annotate_df = function(d) {
	require(biomaRt)
	ensembl = useMart('ensembl', dataset = ensembl_gene)
	a = getBM(attributes=c(filter_type, gene_symbol, "description"),
		filters=c(filter_type), values=d[, 'id'],
		mart=ensembl)
	m = merge(d, a, by.x="id", by.y=filter_type)
	#names(m)[which(names(m)=="Row.names")]= "id"
	return(m)
}
mds = function(counts, genotype, treatment) {
	distances = dist(t(counts))
	fit = cmdscale(distances, eig=TRUE, k=6)
	colnames(fit$points) = c("one", "two", "three", "four", "five", "six")
	df = as.data.frame(fit$points)
	df$label = rownames(df)
        df$genotype = genotype
        df$treatment = treatment
	print(ggplot(df, aes(one, two, color=genotype, shape=treatment))
            + geom_point())
	eigs = data.frame(variance_explained=fit$eig / sum(fit$eig))
	eigs$component = as.integer(rownames(eigs))
	#print(ggplot(eigs, aes(component, variance_explained)) + geom_point())
}
```

First load the data and do some basic cleaning and setup. We are not going to be
able to quantitate non-polyA selected rRNAs very well, so we will remove
them from the analysis since they are noisy. We also set up a the basic
groups for the experiment for pairwise comparisons as well as a design
matrix for a more complicated GLM-based treatment.
```{r data-load}
count_file = "/Users/rory/hsph/hsph/projects/widenmaier_rnaseq/bcbio_test/htseq-count/combined.counts"
counts = read.table(count_file, header=TRUE, row.names="id")
# remove the non-aligned counts
counts = head(counts, -5)
# remove counts for anything on MT or not protein coding/pseudogene
tmp = counts
tmp$id = rownames(counts)
tmp = annotate_df_for_filtering(tmp)
tmp = subset(tmp, gene_biotype %in% c("psuedogene", "protein_coding"))
tmp = subset(tmp, chromosome_name != "MT")
counts = counts[tmp$id,]
sample = colnames(counts)
short_names = unlist(lapply(sample,
                    function(x) str_split(x, ".querysorted")[[1]][1]))
colnames(counts) = short_names
cell_type = unlist(lapply(sample, function(x) str_split(x, "_")[[1]][1]))
condition = unlist(lapply(sample, function(x) str_split(x, "_")[[1]][2]))
replicate = unlist(lapply(sample, function(x) str_split(x, "_")[[1]][3]))
replicate = unlist(lapply(replicate,
                    function(x) str_split(x, ".querysorted")[[1]][1]))
group = data.frame(sample=sample, cell_type=cell_type, condition=condition,
  replicate=replicate)
group$cell_type = relevel(group$cell_type, ref="WT")
group$condition = relevel(group$condition, ref="Con")
design = model.matrix(~ condition + cell_type + condition:cell_type, data=group)
```
<!---
#edgeR.dgelist = DGEList(counts = counts)
#edgeR.dgelist = calcNormFactors(edgeR.dgelist, method = "TMM")
#edgeR.dgelist = estimateGLMCommonDisp(edgeR.dgelist, design)
#edgeR.dgelist = estimateGLMTrendedDisp(edgeR.dgelist, design)
#edgeR.dgelist = estimateGLMTagwiseDisp(edgeR.dgelist, design)
#fit = glmFit(edgeR.dgelist, design)
#lrt = glmLRT(fit)
#topTags(lrt)

#de_table = lrt$table
#de_table$DE = decideTests(de_table)
#de_table$FDR = p.adjust(de_table$PValue, method="BH")
#de_table$id = rownames(de_table)
#x = annotate_df(de_table)
--->

```{r pairwise-setup}
pairwise = paste(group$cell_type, group$condition, sep="_")
edgeR.dgelist = DGEList(counts = counts, group=pairwise)
```

# Normalization
We use the edgeR TMM (trimmed mean of m-values) to perform normalization of the
count data. The effect of performing this normalization is twofold. First,
it pulls the overall fold change between samples closer to zero.

```{r normalization}
edgeR.dgelist = calcNormFactors(edgeR.dgelist, method = "TMM")
```

```{r pre-normalization}
tmp_cpm = data.frame(cpm(edgeR.dgelist, normalized.lib.sizes=FALSE))
q = tmp_cpm/rowMeans(tmp_cpm)
binwidth = diff(range(q, na.rm=TRUE))/100
q$genes = rownames(q)
q = melt(q, id='genes', variable_name='sample')
q = merge(q, group, by.x="sample", by.y="sample")
ggplot(q, aes(value), environment=environment()) +
  geom_histogram(binwidth=0.01) +
  scale_x_log10() + facet_grid(cell_type + condition ~ .) +
ggtitle("log10 counts, pre-TMM")
```
```{r pre-normalization-mds, fig.cap="pre-normalization MDS plot"}
mds(tmp_cpm, cell_type, condition)
```

# Sample swap
From the MDS plot it looks like one of the WT Con samples could be swapped with
a Chol sample, WT_Chol_rep2 with WT_Con_Rep3. From the email exchange, here are
the lanes along with their ids:

| Library     | ID       | Replicate |
|-------------|----------|-----------|
| TRA00010399 | WT\_Con  |         1 |
| TRA00010402 | WT\_Chol |         1 |
| TRA00010405 | KO\_Con  |         1 |
| TRA00010408 | KO\_Chol |         1 |
| TRA00010400 | WT\_Con  |         2 |
| TRA00010403 | WT\_Chol |         2 |
| TRA00010406 | KO\_Con  |         2 |
| TRA00010409 | KO\_Chol |         2 |
| TRA00010401 | WT\_Con  |         3 |
| TRA00010404 | WT\_Chol |         3 |
| TRA00010407 | KO\_Con  |         3 |
| TRA00010410 | KO\_Chol |         3 |

Could those two samples have gotten swapped at one point?

A heatmap of the correlations between the sample seems to support this.
```{r heatmap-correlation}
qplot(x=X1, y=X2, data=melt(cor(counts)), fill=value, geom="tile") +
  opts(axis.text.x=theme_text(angle=-90))
```

```{r post-normalization}
tmp_cpm = data.frame(cpm(edgeR.dgelist))
q = tmp_cpm/rowMeans(tmp_cpm)
binwidth = diff(range(q, na.rm=TRUE))/100
q$genes = rownames(q)
q = melt(q, id='genes', variable_name='sample')
q = merge(q, group, by.x="sample", by.y="sample")
ggplot(q, aes(value), environment=environment()) +
  geom_histogram(binwidth=0.01) +
  scale_x_log10() + facet_grid(cell_type + condition ~ .) +
ggtitle("log10 counts, post-TMM")
```
```{r post-normalization-mds, fig.cap="post-normalization MDS plot"}
mds(tmp_cpm, cell_type, condition)
```

```{r dispersion}
edgeR.dgelist = estimateCommonDisp(edgeR.dgelist)
#edgeR.dgelist = estimateTrendedDisp(edgeR.dgelist)
edgeR.dgelist = estimateTagwiseDisp(edgeR.dgelist, trend = "movingave")
```

# Filtering
To maximize power of the statistical tests, we want to eliminate
genes from consideration that have either no signal or a low,
constant, uninformative signal across experimental conditions. We choose
a threshold maximizing, between each set of replicates, sum of Jaccard index
for all pairwise comparisons of replicates. Genes with counts below this
threshold are removed for consideration.

```{r filtering}
et = exactTest(edgeR.dgelist, pair=c("WT_Con", "KO_Con"))
et = HTSFilter(et, DGEList=edgeR.dgelist, s.len=25)$filteredData
```

# WT control vs KO control
```{r WT_vs_KO, results='asis'}
et = exactTest(edgeR.dgelist, pair=c("WT_Con", "KO_Con"))
et = HTSFilter(et, DGEList=edgeR.dgelist, s.len=25, plot=FALSE)$filteredData
et_table = et$table
et_table$FDR = p.adjust(et_table$PValue, method="BH")
de_table = subset(et_table, FDR < 0.10)
de_table$id = rownames(de_table)
WT_vs_KO = annotate_df(de_table)
print(gvisTable(WT_vs_KO), "chart", options=list(width=900))
```

```{r WT_chol_vs_KO_chol, results='asis'}
et = exactTest(edgeR.dgelist, pair=c("WT_Chol", "KO_Chol"))
et = HTSFilter(et, DGEList=edgeR.dgelist, s.len=25, plot=FALSE)$filteredData
et_table = et$table
et_table$FDR = p.adjust(et_table$PValue, method="BH")
de_table = subset(et_table, FDR < 0.10)
de_table$id = rownames(de_table)
WT_chol_vs_KO_chol = annotate_df(de_table)
print(gvisTable(WT_chol_vs_KO_chol), "chart", options=list(width=900))
```

```{r WT_Con_vs_WT_chol, results='asis'}
et = exactTest(edgeR.dgelist, pair=c("WT_Con", "WT_Chol"))
et = HTSFilter(et, DGEList=edgeR.dgelist, s.len=25, plot=FALSE)$filteredData
et_table = et$table
et_table$FDR = p.adjust(et_table$PValue, method="BH")
de_table = subset(et_table, FDR < 0.10)
de_table$id = rownames(de_table)
WT_vs_WT_chol = annotate_df(de_table)
print(gvisTable(WT_vs_WT_chol), "chart", options=list(width=900))
```

```{r KO_Con_vs_KO_chol, results='asis'}
et = exactTest(edgeR.dgelist, pair=c("KO_Con", "KO_Chol"))
et = HTSFilter(et, DGEList=edgeR.dgelist, s.len=25, plot=FALSE)$filteredData
et_table = et$table
et_table$FDR = p.adjust(et_table$PValue, method="BH")
de_table = subset(et_table, FDR < 0.10)
de_table$id = rownames(de_table)
KO_vs_KO_chol = annotate_df(de_table)
print(gvisTable(KO_vs_KO_chol), "chart", options=list(width=900))
```
